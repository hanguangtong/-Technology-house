异步模块定义规范（AMD）制定了定义模块的规则，这样模块和模块的依赖可以被异步加载。这和浏览器的异步加载模块的环境刚好适应（浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题）。
define() 函数

本规范只定义了一个函数 "define"，它是全局变量。函数的描述为：

    define(id?, dependencies?, factory);
id

名字

第一个参数，id，是个字符串。它指的是定义中模块的名字，这个参数是可选的。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。

模块名的格式

模块名用来唯一标识定义中模块，它们同样在依赖数组中使用。AMD的模块名规范是CommonJS模块名规范的超集。引用如下：

模块名是由一个或多个单词以正斜杠为分隔符拼接成的字符串
单词须为驼峰形式，或者"."，".."
模块名不允许文件扩展名的形式，如".js"
模块名可以为 "相对的" 或 "顶级的"。如果首字符为"."或".."则为"相对的"模块名
顶级的模块名从根命名空间的概念模块解析
相对的模块名从 "require" 书写和调用的模块解析
上文引用的CommonJS模块id属性常被用于JavaScript模块。

相对模块名解析示例：

如果模块 "a/b/c" 请求 "../d", 则解析为"a/d"
如果模块 "a/b/c" 请求 "./e", 则解析为"a/b/e"
如果AMD的实现支持加载器插件(Loader-Plugins),则"!"符号用于分隔加载器插件模块名和插件资源名。由于插件资源名可以非常自由地命名，大多数字符都允许在插件资源名使用。

（译注：关于Loader-Plugins）

依赖

第二个参数，dependencies，是个定义中模块所依赖模块的数组。依赖模块必须根据模块的工厂方法优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂方法中。

依赖的模块名如果是相对的，应该解析为相对定义中的模块。换句话来说，相对名解析为相对于模块的名字，并非相对于寻找该模块的名字的路径。

本规范定义了三种特殊的依赖关键字。如果"require","exports", 或 "module"出现在依赖列表中，参数应该按照CommonJS模块规范自由变量去解析。

依赖参数是可选的，如果忽略此参数，它应该默认为["require", "exports", "module"]。然而，如果工厂方法的形参个数小于3，加载器会选择以函数指定的参数个数调用工厂方法。

工厂方法

第三个参数，factory，为模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。

如果工厂方法返回一个值（对象，函数，或任意强制类型转换为true的值），应该为设置为模块的输出值。

简单的 CommonJS 转换

如果依赖性参数被忽略，模块加载器可以选择扫描工厂方法中的require语句以获得依赖性（字面量形为require("module-id")）。第一个参数必须字面量为require从而使此机制正常工作。

在某些情况下，因为脚本大小的限制或函数不支持toString方法（Opera Mobile是已知的不支持函数的toString方法），模块加载器可以选择扫描不扫描依赖性。

如果有依赖参数，模块加载器不应该在工厂方法中扫描依赖性。

define.amd 属性

为了清晰的标识全局函数（为浏览器加载script必须的）遵从AMD编程接口，任何全局函数应该有一个"amd"的属性，它的值为一个对象。这样可以防止与现有的定义了define函数但不遵从AMD编程接口的代码相冲突。

当前，define.amd对象的属性没有包含在本规范中。实现本规范的作者，可以用它通知超出本规范编程接口基本实现的额外能力。

define.amd的存在表明函数遵循本规范。如果有另外一个版本的编程接口，那么应该定义另外一个属性，如define.amd2，表明实现只遵循该版本的编程接口。

一个如何定义同一个环境中允许多次加载同一个版本的模块的实现：

    define.amd = {
      multiversion: true
    };
最简短的定义：

    define.amd = {};
一次输出多个模块

在一个脚本中可以使用多次define调用。这些define调用的顺序不应该是重要的。早一些的模块定义中所指定的依赖，可以在同一脚本中晚一些定义。模块加载器负责延迟加载未解决的依赖，直到全部脚本加载完毕，防止没必要的请求。

例子
使用 require 和 exports

创建一个名为"alpha"的模块，使用了require，exports，和名为"beta"的模块:

   define("alpha", ["require", "exports", "beta"], function (require, exports, beta) {
       exports.verb = function() {
           return beta.verb();
           //Or:
           return require("beta").verb();
       }
   });
一个返回对象的匿名模块：

   define(["alpha"], function (alpha) {
       return {
         verb: function(){
           return alpha.verb() + 2;
         }
       };
   });
一个没有依赖性的模块可以直接定义对象：

   define({
     add: function(x, y){
       return x + y;
     }
   });
一个使用了简单CommonJS转换的模块定义：

   define(function (require, exports, module) {
     var a = require('a'),
         b = require('b');

     exports.action = function () {};
   });
全局变量
本规范保留全局变量"define"以用来实现本规范。包额外信息异步定义编程接口是为将来的CommonJS API保留的。模块加载器不应在此函数添加额外的方法或属性。

本规范保留全局变量"require"被模块加载器使用。模块加载器可以在合适的情况下自由地使用该全局变量。它可以使用这个变量或添加任何属性以完成模块加载器的特定功能。它同样也可以选择完全不使用"require"。

使用注意
为了使静态分析工具（如build工具）可以正常工作，推荐使用字面上形如的'define(...)'。

与CommonJS的关系
一个关于本API的wiki开始在CommonJS wiki中创建了，作为中转的格式，模块中转。但是为了包含模块定义接口，随着时间而不断改变。在CommonJS列表中关于推荐本API作为模块定义API尚未达成一致。本API被转移到它自己的wiki和讨论组中。
AMD可以作为CommonJS模块一个中转的版本只要CommonJS没有被用来同步的require调用。使用同步require调用的CommonJS代码可以被转换为使用回调风格的AMD模块加载器。
CMD 与 seaJS
CMD
    在CMD中，一个模块就是一个文件，格式为：
    define( factory );

    全局函数define，用来定义模块。
    参数 factory  可以是一个函数，也可以为对象或者字符串。
    当 factory 为对象、字符串时，表示模块的接口就是该对象、字符串。

    定义JSON数据模块：
define({ "foo": "bar" });

    通过字符串定义模板模块：

define('this is {{data}}.');

    factory 为函数的时候，表示模块的构造方法，执行构造方法便可以得到模块向外提供的接口。

define( function(require, exports, module) { 
    // 模块代码
});


    define( id?, deps?, factory );
    define也可以接受两个以上的参数，字符串id为模块标识，数组deps为模块依赖：

define( 'module', ['module1', 'module2'], function( require, exports, module ){
    // 模块代码
} );
    其与 AMD 规范用法不同。

    require 是 factory 的第一个参数。
    require( id );
    接受模块标识作为唯一的参数，用来获取其他模块提供的接口：

define(function( require, exports ){
    var a = require('./a');
    a.doSomething();
});

    require.async( id, callback? );
    require是同步往下执行的，需要的异步加载模块可以使用 require.async 来进行加载：

define( function(require, exports, module) { 
    require.async('.a', function(a){
        a.doSomething();
    });
});

    require.resolve( id )
    可以使用模块内部的路径机制来返回模块路径，不会加载模块。

    exports 是 factory 的第二个参数，用来向外提供模块接口。

define(function( require, exports ){
    exports.foo = 'bar'; // 向外提供的属性
    exports.do = function(){}; // 向外提供的方法
});

    当然也可以使用 return 直接向外提供接口。

define(function( require, exports ){
    return{
        foo : 'bar', // 向外提供的属性
        do : function(){} // 向外提供的方法
    }
});

    也可以简化为直接对象字面量的形式:

define({
    foo : 'bar', // 向外提供的属性
    do : function(){} // 向外提供的方法
});


    与nodeJS中一样需要注意的是，一下方式是错误的：

define(function( require, exports ){
    exports = {
        foo : 'bar', // 向外提供的属性
        do : function(){} // 向外提供的方法
    }
});


    需要这么做

define(function( require, exports, module ){
    module.exports = {
        foo : 'bar', // 向外提供的属性
        do : function(){} // 向外提供的方法
    }
});

    传入的对象引用可以添加属性，一旦赋值一个新的对象，那么值钱传递进来的对象引用就会失效了。开始之初，exports 是作为 module.exports 的一个引用存在，一切行为只有在这个引用上 factory 才得以正常运行，赋值新的对象后就会断开引用，exports就只是一个新的对象引用，对于factory来说毫无意义，就会出错。

    module 是factory的第三个参数，为一个对象，上面存储了一些与当前模块相关联的属性与方法。
        module.id 为模块的唯一标识。
        module.uri 根据模块系统的路径解析规则得到模块的绝对路径。
        module.dependencies 表示模块的依赖。
        module.exports 当前模块对外提供的接口。


seaJS
    官网 http://seajs.org/docs/
    API快速参考 https://github.com/seajs/seajs/issues/266
    sea.js 核心特征：
        1. 遵循CMD规范，与NodeJS般的书写模块代码。
        2. 依赖自动加载，配置清晰简洁。
    兼容 Chrome 3+，Firefox 2+，Safari 3.2+，Opera 10+，IE 5.5+。

    seajs.use 
    用来在页面中加载一个或者多个模块

// 加载一个模块 
seajs.use('./a');
// 加载模块，加载完成时执行回调
seajs.use('./a'，function(a){
    a.doSomething();
});
// 加载多个模块执行回调
seajs.use(['./a','./b']，function(a , b){
    a.doSomething();
    b.doSomething();
});

    其define 与 require 使用方式基本就是CMD规范中的示例。


AMD 与 CMD 区别到底在哪里？

    看了以上 AMD，requireJS 与 CMD， seaJS的简单介绍会有点感觉模糊，总感觉较为相似。因为像 requireJS 其并不是只是纯粹的AMD固有思想，其也是有CMD规范的思想，只不过是推荐 AMD规范方式而已， seaJS也是一样。

    下面是玉伯对于 AMD 与 CMD 区别的解释：

    AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
    CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。

    类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出还有不少??

    这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。
    目前这些规范的实现都能达成浏览器端模块化开发的目的。

    区别：

    1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
    2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：

// CMD
define(function(require, exports, module) {
    var a = require('./a')
    a.doSomething()
    // 此处略去 100 行
    var b = require('./b') // 依赖可以就近书写
    b.doSomething()
    // ...
})

// AMD 默认推荐的是
define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
    a.doSomething()
    // 此处略去 100 行
    b.doSomething()
    // ...
})

虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。
    3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。
    4. 还有一些细节差异，具体看这个规范的定义就好，就不多说了。
另外，SeaJS 和 RequireJS 的差异，可以参考：https://github.com/seajs/seajs/issues/277

总结
    本文主要是介绍了一下 AMD CMD的规范，顺便简单的讲述了一下 requireJS 与 seaJS。讲的较为笼统，下面的扩展阅读可以更好的帮助你理解模块化以及各个规范。


扩展阅读：

AMD规范文档 https://github.com/amdjs/amdjs-api/wiki/AMD
amdjs 的 require 接口文档 https://github.com/amdjs/amdjs-api/wiki/require
amdjs 的接口文档 https://github.com/amdjs/amdjs-api/wiki
RequireJS官网接口文档  http://www.requirejs.org/docs/api.html 

模块系统 https://github.com/seajs/seajs/issues/240
前端模块化开发的价值 https://github.com/seajs/seajs/issues/547
前端模块化开发那点历史 https://github.com/seajs/seajs/issues/588
CMD 模块定义规范 https://github.com/seajs/seajs/issues/242
SeaJS API快速参考 https://github.com/seajs/seajs/issues/266
从 CommonJS 到 Sea.js https://github.com/seajs/seajs/issues/269    

RequireJS和AMD规范  http://javascript.ruanyifeng.com/tool/requirejs.html 
CommonJS规范  http://javascript.ruanyifeng.com/nodejs/commonjs.html
Javascript模块化编程 http://www.ruanyifeng.com/blog/2012/10/javascript_module.html
Javascript模块化编程 http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html

知乎  AMD 和 CMD 的区别有哪些？ http://www.zhihu.com/question/20351507 

JavaScript模块化开发 - CommonJS规范 http://www.feeldesignstudio.com/2013/09/javascript-module-pattern-commonjs 
JavaScript模块化开发 - AMD规范 http://www.feeldesignstudio.com/2013/09/javascript-module-pattern-amd

模块化设计 http://baike.baidu.com/view/189730.htm 
模块化  http://baike.baidu.com/view/182267.htm 

